<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_World</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_gameUpdatedParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// controller for spawning world chunks
randomize();
var worldName = "Test World Rand";
UniverseNumber = 0;

// setup world data based on the seed(for fresh chunks!)
if(file_exists(working_directory + "/Worlds/" + string(worldName) + "/World.dat"))
{
    scr_LoadWorld(worldName);
}
else
{
    scr_WorldGen(random(9999),worldName); 
    scr_SaveWorld();
}
    


global.currentCameraZLevel = global.worldData[? "seaLevel"];

loadedChunkList = ds_list_create();

var TLgridX = (floor(view_xview[0] / (global.chunkWidth  * 16))-1) * (global.chunkWidth  * 16);
var TLgridY = (floor(view_yview[0] / (global.chunkHeight * 16))-1) * (global.chunkHeight * 16);

x = TLgridX;
y = TLgridY;


pendingEntitySpawns = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(loadedChunkList);
ds_list_destroy(pendingEntitySpawns);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// create a world chunk
// x and y of world object should be moved to the spot you want it!

var chunkAlreadyHere = false;
for (i=0; i&lt;ds_list_size(loadedChunkList); i+=1)
{
    var chunk = loadedChunkList[| i];
    if(chunk.x == x &amp;&amp; chunk.y == y)
    {
        chunkAlreadyHere = true;
        break;
    }
};


global.loadingTimer -= 1;
if(global.loadingTimer &lt;= 0 &amp;&amp; !chunkAlreadyHere)
{
    // reset loading timer
    global.loadingTimer = irandom(10) + 20;
    
    // spawn world chunk!
    var newChunk = instance_create(x,y,obj_WorldChunk);
    newChunk.worldController = id;
    
    if(file_exists(working_directory + "/Worlds/" + string(global.worldData[? "name"]) + "/Universe" + string(UniverseNumber) + "/Chunks/" + string(x/16) + "o" + string(y/16) + ".dat"))
    {
        // not new, load chunk data!
        with newChunk
        {
            if(global.debug_ChunkLoadingInfo) show_debug_message("STARTED Loading chunk " + string(id));
            scr_LoadChunk(worldController.UniverseNumber,id);
            processing = true; // if entitys should be updated
            rendering = true; // if chunk is drawn
            forceRenderUpdate = true;
            initialGen = false;
            if(global.debug_ChunkLoadingInfo) show_debug_message("Loaded chunk " + string(id));
        }
    }
    else
    {
        // new! setup for WORLDGEN
        initialGen = true;
        if(global.debug_ChunkLoadingInfo) show_debug_message("Spawned chunk " + string(newChunk.id));
    }
    
    
    
    ds_list_add(loadedChunkList, newChunk);
    
    
    // Connect neighbouring chunks!
    newChunk.neighbour_north = instance_place(x, y - 16*global.chunkHeight, obj_WorldChunk);
    with newChunk.neighbour_north
    {
        neighbour_south = newChunk;
        forceRenderUpdate = true;
    }
    
    newChunk.neighbour_south = instance_place(x, y + 16*global.chunkHeight, obj_WorldChunk);
    with newChunk.neighbour_south
    {
        neighbour_north = newChunk;
        forceRenderUpdate = true;
    }
    
    newChunk.neighbour_east = instance_place(x + 16*global.chunkWidth, y, obj_WorldChunk);
    with newChunk.neighbour_east
    {
        neighbour_west = newChunk;
        forceRenderUpdate = true;
    }
    
    newChunk.neighbour_west = instance_place(x - 16*global.chunkWidth, y, obj_WorldChunk);
    with newChunk.neighbour_west
    {
        neighbour_east = newChunk;
        forceRenderUpdate = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// move along chunk sized steps, and do a chunk spawn check
// based on the view's current location!
var chunkW = global.chunkWidth * 16;
var chunkH = global.chunkHeight * 16;

var TLgridX = (floor(view_xview[0] / chunkW)-1) * chunkW;
var TLgridY = (floor(view_yview[0] / chunkH)-1) * chunkH;


// stepping movements
x += chunkW;
if(x &gt; view_xview[0] + view_wview[0] + chunkW * 2)
{
    x = TLgridX - (chunkW * 2);
    y += chunkH;
}
if(y &gt; view_yview[0] + view_hview[0] + chunkH * 2)
{
    y = TLgridY - (chunkH * 2);
}


global.unloadingTimer -= 1;
if(global.unloadingTimer &lt; 0)
{
    global.unloadingTimer = irandom(50) + 50;
}



// clear draw priority
ds_priority_clear(global.drawDepthPriority);
ds_list_clear(global.drawList);


// spawn chunk
event_user(1);


// entity loading control
if(global.AllowUpdateCounter == 0)
{
    if(ds_list_size(pendingEntitySpawns) &gt; 0)
    {
        with pendingEntitySpawns[| 0] event_user(0); // attempt spawn
        if(pendingEntitySpawns[| 0].ActiveChunk != noone)
        {
            // clear from list
            ds_list_delete(pendingEntitySpawns,0);
        }
    }
}


// update chunks
for (i=0; i&lt;ds_list_size(loadedChunkList); i+=1)
{
    var chunk = loadedChunkList[| i];
    scr_ChunkUpdate(chunk, (random(10) &lt; 0.1) );
    scr_ChunkEntityUpdate(chunk);
    
    // get cached draw data!
    for (var t=0; t&lt;ds_list_size(chunk.drawList); t+=1)
    {
        var packOut = chunk.drawList[| t];
        var newDrawData = ds_list_create();
        ds_list_add(newDrawData,packOut[| 0],packOut[| 2]);
        
        ds_priority_add(global.drawDepthPriority,    newDrawData,   packOut[| 1]);
        
    }
}

// setup draw list, sort out from depth and only store ID and type
var disposableQueue = ds_priority_create();
ds_priority_copy(disposableQueue, global.drawDepthPriority);
while(ds_priority_size(disposableQueue) &gt; 0)
{
    // extract data
    drawData = ds_priority_delete_min(disposableQueue);
    
    //PackinData:  ID, depth, block(truefalse)
    ds_list_add(global.drawList,drawData[| 0],drawData[| 1]);
    ds_list_destroy(drawData);
}
ds_priority_destroy(disposableQueue);


// setup loop flags
global.AllowUpdateCounter -= 1;
if(global.AllowUpdateCounter &lt; 0)
{
    global.AllowUpdateCounter = 1; // 30 ticks for entity updates
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(loadedChunkList);
ds_list_destroy(pendingEntitySpawns);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw all objects

// hold the last updated draw priority queue, and make a disposable priority queue to burn through

// burn through all drawable objects
for (var i=ds_list_size(global.drawList)-2; i&gt; 0; i-=2)
{
    //PackinData:  ID, block(truefalse)
    var drawData = global.drawList[| i+0];
    
    if(global.drawList[| i+1])
    {
        var xx = drawData[? "x"];
        var yy = drawData[? "y"];
        var zz = drawData[? "z"]
        var yOffset = scr_DrawYOffset(xx,yy,zz);
        
        var solveAlpha = ((global.currentCameraZLevel - (zz/16))-2) / -global.drawLayerDepth;
        var exposure = drawData[? "Exposed"];
        
        
        if(drawData != -1) 
        {
            if(exposure == 0)
            {
                draw_sprite_ext(spr_blockDarken,0   , xx, yy + yOffset, 1, 1, 0, image_blend, 1);
            }
            else if(floor(zz/16) &gt;= floor(global.currentCameraZLevel))
            {
                draw_sprite_ext(drawData[? "Tex"],0, xx, yy + yOffset, 1, 1, 0, image_blend, 1);
                draw_sprite_ext(spr_blockDarken,0   , xx, yy + yOffset, 1, 1, 0, image_blend, solveAlpha);
                
                if(exposure == 2)
                {
                    draw_sprite_ext(spr_blockBackReveal,0   , xx, yy + yOffset, 1, 1, 0, image_blend, 1);
                }
            }
            else if(floor(zz/16) == floor(global.currentCameraZLevel-1))
            {
                draw_sprite_ext(drawData[? "Tex"],0, xx, yy + yOffset, 1, 1, 0, image_blend, 1);
                draw_sprite_ext(spr_blockDarken,0   , xx, yy + yOffset, 1, 1, 0, image_blend, 0.1);
            }
            else
            {
                draw_sprite_ext(drawData[? "Tex"],0, xx, yy + yOffset, 1, 1, 0, image_blend, 1);
            }
        }
    }
    else
    {
        with drawData event_perform(ev_draw,0);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
