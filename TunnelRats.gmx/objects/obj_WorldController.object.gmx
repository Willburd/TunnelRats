<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_World</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_gameUpdatedParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// controller for spawning world chunks
randomize();
var worldName = "Test World Rand";
UniverseNumber = 0;

// setup world data based on the seed(for fresh chunks!)
if(file_exists(working_directory + "/Worlds/" + string(worldName) + "/World.dat"))
{
    scr_LoadWorld(worldName);
}
else
{
    scr_WorldGen(random(9999),worldName); 
    scr_SaveWorld();
}
    


global.currentCameraZLevel = global.worldData[? "seaLevel"];

loadedChunkList = ds_list_create();

var TLgridX = (floor(view_xview[0] / (global.chunkWidth  * 16))-1) * (global.chunkWidth  * 16);
var TLgridY = (floor(view_yview[0] / (global.chunkHeight * 16))-1) * (global.chunkHeight * 16);

x = TLgridX;
y = TLgridY;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(loadedChunkList);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// create a world chunk
// x and y of world object should be moved to the spot you want it!

var chunkAlreadyHere = false;
for (i=0; i&lt;ds_list_size(loadedChunkList); i+=1)
{
    var chunk = loadedChunkList[| i];
    if(chunk.x == x &amp;&amp; chunk.y == y)
    {
        chunkAlreadyHere = true;
        break;
    }
};

if(!chunkAlreadyHere)
{
    // spawn world chunk!
    var newChunk = instance_create(x,y,obj_WorldChunk);
    newChunk.worldController = id;
    if(file_exists(working_directory + "/Worlds/" + string(global.worldData[? "name"]) + "/Universe" + string(UniverseNumber) + "/Chunks/" + string(x/16) + "o" + string(y/16) + ".dat"))
    {
        // not new, load chunk data!
        with newChunk
        {
            show_debug_message("STARTED Loading chunk " + string(id));
            scr_LoadChunk(UniverseNumber,id);
            processing = true; // if entitys should be updated
            rendering = true; // if chunk is drawn
            forceRenderUpdate = true;
            initialGen = false;
            show_debug_message("Loaded chunk " + string(id));
        }
    }
    else
    {
        // new! setup for WORLDGEN
        initialGen = true;
        show_debug_message("Spawned chunk " + string(newChunk.id));
    }
    
    
    
    ds_list_add(loadedChunkList, newChunk);
    
    
    // Connect neighbouring chunks!
    newChunk.neighbour_north = instance_place(x, y - 16*global.chunkHeight, obj_WorldChunk);
    with newChunk.neighbour_north
    {
        neighbour_south = newChunk;
        forceRenderUpdate = true;
    }
    
    newChunk.neighbour_south = instance_place(x, y + 16*global.chunkHeight, obj_WorldChunk);
    with newChunk.neighbour_south
    {
        neighbour_north = newChunk;
        forceRenderUpdate = true;
    }
    
    newChunk.neighbour_east = instance_place(x + 16*global.chunkWidth, y, obj_WorldChunk);
    with newChunk.neighbour_east
    {
        neighbour_west = newChunk;
        forceRenderUpdate = true;
    }
    
    newChunk.neighbour_west = instance_place(x - 16*global.chunkWidth, y, obj_WorldChunk);
    with newChunk.neighbour_west
    {
        neighbour_east = newChunk;
        forceRenderUpdate = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// move along chunk sized steps, and do a chunk spawn check
// based on the view's current location!
var chunkW = global.chunkWidth * 16;
var chunkH = global.chunkHeight * 16;

var TLgridX = (floor(view_xview[0] / chunkW)-1) * chunkW;
var TLgridY = (floor(view_yview[0] / chunkH)-1) * chunkH;


// stepping movements
x += chunkW;
if(x &gt; view_xview[0] + view_wview[0] + chunkW + 20)
{
    x = TLgridX;
    y += chunkH;
}
if(y &gt; view_yview[0] + view_hview[0] + chunkH + 20)
{
    y = TLgridY;
}


// update chunks
for (i=0; i&lt;ds_list_size(loadedChunkList); i+=1)
{
    var chunk = loadedChunkList[| i];
    
    if(rectangle_in_rectangle(chunk.x,chunk.y,chunk.x+global.chunkWidth*16,chunk.y+global.chunkHeight*16,view_xview[0]-96,view_yview[0]-96,view_xview[0]+view_wview[0]+96,view_yview[0]+view_hview[0]+96) &gt; 0)
    {
        scr_ChunkUpdate(chunk, (random(1) &lt; 0.1) );
    }
}


// spawn chunk
event_user(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(loadedChunkList);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
