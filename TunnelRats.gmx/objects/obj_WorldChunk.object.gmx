<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_WorldChunk</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_colMask8x</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>processing = true; // if entitys should be updated
rendering = true; // if chunk is drawn

forceRenderUpdate = false;
updateTimerMax = 20; // delay between updates
updateTimer = 0; // timer for it

entitys = ds_list_create(); // all entity ds_map datas
ground = -1;  // the chunk sized grid of terrain ground under the walls
walls = -1;   // the chunk sized grid of solid walls 
floors = -1;  // the chunk sized grid of placed flooring/plants
zdata = -1;


// graphical tile storage
puppetWalls = ds_grid_create(global.chunkWidth,global.chunkHeight);
ds_grid_clear(puppetWalls,-1);
puppetGround = ds_grid_create(global.chunkWidth,global.chunkHeight);
ds_grid_clear(puppetGround,-1);
puppetFloors = ds_grid_create(global.chunkWidth,global.chunkHeight);
ds_grid_clear(puppetFloors,-1);


worldController = noone;

neighbour_north = noone;
neighbour_south = noone;
neighbour_east = noone;
neighbour_west = noone;
depth = -y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_SaveChunk(worldController.UniverseNumber,id);
ds_list_destroy(entitys);

// clean out puppet tiles
for (q=0; q&lt;global.chunkWidth; q+=1)
{
    for (c=0; c&lt;global.chunkHeight; c+=1)
    {
        if(puppetWalls[# q,c] != -1)
        {
            var getPackIn = puppetWalls[# q,c];
            while(ds_list_size(getPackIn) &gt; 0)
            {
                tile_delete( getPackIn[| 0]);
                ds_list_delete(getPackIn,0);
            }
            puppetWalls[# q,c] = -1;
        }
        
        if(puppetFloors[# q,c] != -1)
        {
            var getPackIn = puppetFloors[# q,c]
            while(ds_list_size(getPackIn) &gt; 0)
            {
                tile_delete( getPackIn[| 0]);
                ds_list_delete(getPackIn,0);
            }
            puppetFloors[# q,c] = -1;
        }
        
        if(puppetGround[# q,c] != -1)
        {
            var getPackIn = puppetGround[# q,c]
            while(ds_list_size(getPackIn) &gt; 0)
            {
                tile_delete( getPackIn[| 0]);
                ds_list_delete(getPackIn,0);
            }
            puppetGround[# q,c] = -1;
        }
    }
}

// clear grids
ds_grid_destroy(ground);
ds_grid_destroy(walls);
ds_grid_destroy(floors);
ds_grid_destroy(puppetWalls);
ds_grid_destroy(puppetFloors);
ds_grid_destroy(puppetGround);


// tell controller we are dead
var chunkId = id;

with worldController
{
    for (var i=0; i&lt;ds_list_size(loadedChunkList); i+=1)
    {
        if(loadedChunkList[| i] == chunkId)
        {
            if(global.debug_ChunkLoadingInfo) show_debug_message("Unloaded chunk " + string(scr_ChunkName(chunkId)));
            ds_list_delete(loadedChunkList,i);
            break;
        }
    }  
}


// disconnect neighbouring chunks
if(neighbour_north != noone) with neighbour_north { neighbour_south = noone };
if(neighbour_south != noone) with neighbour_south { neighbour_north = noone };
if(neighbour_east != noone) with neighbour_east { neighbour_west = noone };
if(neighbour_west != noone) with neighbour_west { neighbour_east = noone };
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Gen chunk and save!
if(ground == -1) // check is already genned!
{
    walls = ds_grid_create(global.chunkWidth,global.chunkHeight);   // the chunk sized grid of solid walls 
    ground = ds_grid_create(global.chunkWidth,global.chunkHeight);  // the chunk sized grid of terrain ground under the walls
    floors = ds_grid_create(global.chunkWidth,global.chunkHeight);  // the chunk sized grid of placed flooring/plants
    
    zdata = ds_grid_create(global.chunkWidth,global.chunkHeight); // world gen ground Z height
    ds_grid_clear( zdata , 0);  // set zdata to 0;
    
    // spawn objects
    for (var q=0; q&lt;global.chunkWidth; q+=1)
    {
        for (var c=0; c&lt;global.chunkHeight; c+=1)
        {
            // get zheight from world gen and store the zdata
            zdata[# q,c] = scr_GetGroundHeight(floor(x/16)+q,floor(y/16)+c);
            
            // get a ds_map of the block at the location
            var wallData =   scr_WorldGenWalls(  walls,zdata[# q,c],floor(x/16),floor(y/16),q,c);
            var groundData = scr_WorldGenGround(ground,zdata[# q,c],floor(x/16),floor(y/16),q,c);
            var floorsData = -1;
            
            scr_ChunkInternalSetBlock(id, q,c,wallData,BlockGridType.walls);
            scr_ChunkInternalSetBlock(id, q,c,groundData,BlockGridType.ground);
            scr_ChunkInternalSetBlock(id, q,c,floorsData,BlockGridType.floors);
        }
    }
    
    
    
    if(global.debug_ChunkLoadingInfo) show_debug_message("generated chunk: " + scr_ChunkName(id));
    scr_SaveChunk(worldController.UniverseNumber,id);
    
    processing = true; // if entitys should be updated
    rendering = true; // if chunk is drawn
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// chunk update, updates entities in chunk

// update timer
updateTimer--;

// too far out of range to update
if(rectangle_in_rectangle(x,y,x+global.chunkWidth*16,y+global.chunkHeight*16,view_xview[0]-256,view_yview[0]-256,view_xview[0]+view_wview[0]+256,view_yview[0]+view_hview[0]+256) == 0)
{   
    processing = false;
    exit;
}
else
{
    processing = true;
}

// update lockdown
if(updateTimer &gt; 0) exit; // skip update
updateTimer = updateTimerMax + irandom(20);


// draw distance check
if(rectangle_in_rectangle(x,y,x+global.chunkWidth*16,y+global.chunkHeight*16,view_xview[0]-64,view_yview[0]-64,view_xview[0]+view_wview[0]+64,view_yview[0]+view_hview[0]+64) &gt; 0)
{
    rendering = true;
}
else
{
    rendering = false;
}


// check if the chunk has been genned yet!
if(ground == -1 || walls == -1 || floors == -1)
{
    // Gen world!
    event_user(1);
}


// call update in each block
for (q=0; q&lt;global.chunkWidth; q+=1)
{
    for (c=0; c&lt;global.chunkHeight; c+=1)
    {
        // get block data
        var WData = walls[# q,c];
        var GData = ground[# q,c];
        var FData = floors[# q,c];
        
        
        if(WData == -1 || scr_BlockCheckTransparent(WData))
        {
            // GROUND UPDATE SEGMENT! ==========================================================================================================
            if(GData != -1)
            {
                var xxx = GData[? "x"];
                var yyy = GData[? "y"];
                var zzz = GData[? "z"];
            
                // can see ground
                // run update script for block type
                var forceRenderBlock = false;
                GData[? "NeedUpdate"]--; // counter update
                if(GData[? "NeedUpdate"] == true)
                {
                    GData[? "NeedUpdate"] = -1;
                    forceRenderBlock = true;
                }
                else if(GData[? "NeedUpdate"] &lt; -1)
                {
                    GData[? "NeedUpdate"]  = -1;
                }
                
                // can see ground under the floor
                if(rendering &amp;&amp; (forceRenderBlock || forceRenderUpdate))
                {
                    if(FData == -1 || scr_BlockCheckTransparent(FData))
                    {
                        // render GROUND
                        forceRenderBlock = false;
                        
                        // clean block graphics
                        if(puppetGround[# q,c] != -1)
                        {
                            var getPackIn = puppetGround[# q,c];
                            while(ds_list_size(getPackIn) &gt; 0)
                            {
                                tile_delete( getPackIn[| 0]);
                                ds_list_delete(getPackIn,0);
                            }
                            puppetGround[# q,c] = -1;
                        }
                        
                        // spawn updated puppet!
                        puppetGround[# q,c] = scr_BlockDataToGroundTile(GData,id,q,c);
                    }
                }
            }
            
            
            // floors cannot exist under a wall!
            if(WData == -1)
            {
                // FLOOR UPDATE SEGMENT! ==========================================================================================================
                if(FData != -1)
                {
                    var xxx = FData[? "x"];
                    var yyy = FData[? "y"];
                    var zzz = FData[? "z"];
                    
                    // run update script for block type
                    var forceRenderBlock = false;
                    FData[? "NeedUpdate"]--; // counter update
                    if(FData[? "NeedUpdate"] == 0)
                    {
                        FData[? "NeedUpdate"] = -1;
                        forceRenderBlock = true;
                    }
                    else if(FData[? "NeedUpdate"] &lt; -1)
                    {
                        FData[? "NeedUpdate"]  = -1;
                    }
                    
                    if(rendering &amp;&amp; (forceRenderBlock || forceRenderUpdate))
                    {
                        // render FLOOR
                        forceRenderBlock = false;
                        
                        // clean block graphics
                        if(puppetFloors[# q,c] != -1)
                        {
                            var getPackIn = puppetFloors[# q,c];
                            while(ds_list_size(getPackIn) &gt; 0)
                            {
                                tile_delete( getPackIn[| 0]);
                                ds_list_delete(getPackIn,0);
                            }
                            puppetFloors[# q,c] = -1;
                        }
                        
                        // spawn updated puppet!
                        puppetFloors[# q,c] = scr_BlockDataToFloorTile(FData,id,q,c);
                    }
                }
            }
        }
        else
        {
            // WALL UPDATE SEGMENT! ==========================================================================================================
            var xxx = WData[? "x"];
            var yyy = WData[? "y"];
            var zzz = WData[? "z"];
        
            // run update script for block type
            var forceRenderBlock = false;
            WData[? "NeedUpdate"]--; // counter update
            if(WData[? "NeedUpdate"] == 0)
            {
                WData[? "NeedUpdate"] = -1; 
                forceRenderBlock = true;
            }
            else if(WData[? "NeedUpdate"] &lt; -1)
            {
                WData[? "NeedUpdate"]  = -1;
            }
            
            // set visual state of block for drawing
            if(rendering &amp;&amp; (forceRenderBlock || forceRenderUpdate))
            {
                // clean block graphics
                if(puppetWalls[# q,c] != -1)
                {
                    var getPackIn = puppetWalls[# q,c];
                    while(ds_list_size(getPackIn) &gt; 0)
                    {
                        tile_delete( getPackIn[| 0]);
                        ds_list_delete(getPackIn,0);
                    }
                    puppetWalls[# q,c] = -1;
                }
                
                // spawn updated puppet!
                puppetWalls[# q,c] = scr_BlockDataToWallTile(WData,id,q,c);
            }
        }
    }
}


// cleanup one loop flags
forceRenderUpdate = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_destroy();
if(instance_number(obj_WorldChunk) &lt;= 0)
{
    with obj_WorldController instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>nodraw</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
