<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_WorldChunk</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>processing = true; // if entitys should be updated
rendering = true; // if chunk is drawn

forceRenderUpdate = false;
updateTimerMax = 30; // delay between updates
updateTimer = 0; // timer for it

entitys = ds_list_create(); // all entity ds_map datas
ground = -1;  // the chunk sized grid of terrain ground under the walls
walls = -1;   // the chunk sized grid of solid walls 
floors = -1;  // the chunk sized grid of placed flooring/plants
zdata = -1; // layer heights
bdata = -1; // layer biomes

collisionData = ds_grid_create(global.chunkWidth,global.chunkHeight);

// graphical tile storage
puppetWalls = ds_grid_create(global.chunkWidth,global.chunkHeight);
ds_grid_clear(puppetWalls,-1);
puppetGround = ds_grid_create(global.chunkWidth,global.chunkHeight);
ds_grid_clear(puppetGround,-1);
puppetFloors = ds_grid_create(global.chunkWidth,global.chunkHeight);
ds_grid_clear(puppetFloors,-1);


worldController = noone;

neighbour_north = noone;
neighbour_south = noone;
neighbour_east = noone;
neighbour_west = noone;
depth = -y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>processing = false;
rendering = false;


if(walls != -1)
{
    // only save if genned!
    scr_ChunkSave(worldController.UniverseNumber,id,worldController.LoadedLayer);
}

// clean out puppets and tiles! 
for (q=0; q&lt;global.chunkWidth; q+=1)
{
    for (c=0; c&lt;global.chunkHeight; c+=1)
    {
        if(puppetWalls[# q,c] != -1)
        {
            var getPackIn = puppetWalls[# q,c];
            while(ds_list_size(getPackIn) &gt; 0)
            {
                tile_delete( getPackIn[| 0]);
                ds_list_delete(getPackIn,0);
            }
            ds_list_destroy(getPackIn);
            puppetWalls[# q,c] = -1;
        }
        if(walls != -1 &amp;&amp; walls[# q,c] != -1)
        {
            ds_map_destroy(walls[# q,c]);
        }
        
        if(puppetFloors[# q,c] != -1)
        {
            var getPackIn = puppetFloors[# q,c]
            while(ds_list_size(getPackIn) &gt; 0)
            {
                tile_delete( getPackIn[| 0]);
                ds_list_delete(getPackIn,0);
            }
            ds_list_destroy(getPackIn);
            puppetFloors[# q,c] = -1;
        }
        if(floors != -1 &amp;&amp; floors[# q,c] != -1)
        {
            ds_map_destroy(floors[# q,c]);
        }
        
        if(puppetGround[# q,c] != -1)
        {
            var getPackIn = puppetGround[# q,c]
            while(ds_list_size(getPackIn) &gt; 0)
            {
                tile_delete( getPackIn[| 0]);
                ds_list_delete(getPackIn,0);
            }
            ds_list_destroy(getPackIn);
            puppetGround[# q,c] = -1;
        }
        if(ground != -1 &amp;&amp; ground[# q,c] != -1)
        {
            ds_map_destroy(ground[# q,c]);
        }
    }
}


// clear grids
if(walls != -1) ds_grid_destroy(walls);
if(ground != -1) ds_grid_destroy(ground);
if(floors != -1) ds_grid_destroy(floors);
if(zdata != -1) ds_grid_destroy(zdata);
if(bdata != -1) ds_grid_destroy(bdata);

// clean out entities on unload
while (ds_list_size(entitys) &gt; 0)
{
    if(entitys[| 0] != noone) with entitys[| 0] instance_destroy(); 
    ds_list_delete(entitys, 0);
}
ds_list_destroy(entitys);

ds_grid_destroy(collisionData);

ds_grid_destroy(puppetWalls);
ds_grid_destroy(puppetFloors);
ds_grid_destroy(puppetGround);

// tell controller we are dead
var chunkId = id;

with worldController
{
    for (var i=0; i&lt;ds_list_size(loadedChunkList); i+=1)
    {
        if(loadedChunkList[| i] == chunkId)
        {
            if(global.debug_ChunkLoadingInfo) show_debug_message("Unloaded chunk " + string(scr_ChunkName(chunkId)));
            ds_list_delete(loadedChunkList,i);
            break;
        }
    }  
}


// disconnect neighbouring chunks
if(neighbour_north != noone) with neighbour_north { neighbour_south = noone };
if(neighbour_south != noone) with neighbour_south { neighbour_north = noone };
if(neighbour_east != noone) with neighbour_east { neighbour_west = noone };
if(neighbour_west != noone) with neighbour_west { neighbour_east = noone };
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Gen chunk and save!
if(ground == -1) // check is already genned!
{
    walls = ds_grid_create(global.chunkWidth,global.chunkHeight);   // the chunk sized grid of solid walls 
    ground = ds_grid_create(global.chunkWidth,global.chunkHeight);  // the chunk sized grid of terrain ground under the walls
    floors = ds_grid_create(global.chunkWidth,global.chunkHeight);  // the chunk sized grid of placed flooring/plants
    
    bdata = ds_grid_create(global.chunkWidth,global.chunkHeight); // world gen ground Z height
    ds_grid_clear( bdata , -1);  // set bdata to -1;
    zdata = ds_grid_create(global.chunkWidth,global.chunkHeight); // world gen ground Z height
    ds_grid_clear( zdata , 0);  // set zdata to 0;
    
    // spawn objects
    for (var q=0; q&lt;global.chunkWidth; q+=1)
    {
        for (var c=0; c&lt;global.chunkHeight; c+=1)
        {
            random_set_seed(global.worldData[? "seed"] + (floor(x/global.tilePixelSize) + q) + ((floor(y/global.tilePixelSize) + c)*global.tilePixelSize) + (256*worldController.LoadedLayer))
            
            // get zheight from world gen and store the zdata
            bdata[# q,c] = scr_GetBiomeData(floor(x/global.tilePixelSize)+q,floor(y/global.tilePixelSize)+c); // stores the INDEX to the current global.layerLoadedBiomes list!
            zdata[# q,c] = scr_GetGroundHeight(floor(x/global.tilePixelSize)+q,floor(y/global.tilePixelSize)+c,bdata[# q,c]);
            
            //show_debug_message("WALLGEN===============================================================");
            // get a ds_map of the block at the location
            var wallData =   scr_WorldGenWalls(id,zdata[# q,c],bdata[# q,c],floor(x/global.tilePixelSize),floor(y/global.tilePixelSize),q,c);
            scr_ChunkInternalSetBlock(id, q,c,wallData,BlockGridType.walls);
            
            //show_debug_message("GROUNDGEN===============================================================");
            var groundData = scr_WorldGenGround(id,zdata[# q,c]-1,bdata[# q,c],floor(x/global.tilePixelSize),floor(y/global.tilePixelSize),q,c);
            scr_ChunkInternalSetBlock(id, q,c,groundData,BlockGridType.ground);
            
            //show_debug_message("FLOORGEN===============================================================");
            var floorsData = scr_WorldGenFloors(id,zdata[# q,c],bdata[# q,c],floor(x/global.tilePixelSize),floor(y/global.tilePixelSize),q,c);
            scr_ChunkInternalSetBlock(id, q,c,floorsData,BlockGridType.floors);
            
            // update collisions
            scr_ChunkUpdateCollision(id,q,c);
        }
    }
    
    randomize();
    
    if(global.debug_ChunkLoadingInfo) show_debug_message("generated chunk: " + scr_ChunkName(id));
    scr_ChunkSave(worldController.UniverseNumber,id,worldController.LoadedLayer);
    
    processing = true; // if entitys should be updated
    rendering = true; // if chunk is drawn
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// chunk update, updates entities in chunk

// update timer
updateTimer -= scr_DTscale(1);

// too far out of range to update
if(rectangle_in_rectangle(x,y,x+global.chunkWidth*global.tilePixelSize,y+global.chunkHeight*global.tilePixelSize,view_xview[0]-256,view_yview[0]-256,view_xview[0]+view_wview[0]+256,view_yview[0]+view_hview[0]+256) == 0)
{   
    processing = false;
    exit;
}
else
{
    processing = true;
    
    // draw distance check
    var lastRendering = rendering;
    if(rectangle_in_rectangle(x,y,x+global.chunkWidth*global.tilePixelSize,y+global.chunkHeight*global.tilePixelSize,view_xview[0]-96,view_yview[0]-96,view_xview[0]+view_wview[0]+96,view_yview[0]+view_hview[0]+96) &gt; 0)
    {
        rendering = true;
        if(ds_exists(ds_type_list,puppetGround) &amp;&amp; ds_list_size(puppetGround) == 0)
        {
            forceRenderUpdate = true;
        }
    }
    else
    {
        rendering = false;
    }
}


// update lockdown
if(updateTimer &gt; 0 || global.chunkUpdateBudget &gt; 2) exit; // skip update
updateTimer = updateTimerMax + irandom(10);
global.chunkUpdateBudget += 1;

// check if the chunk has been genned yet!
if(ground == -1 || walls == -1 || floors == -1)
{
    // Gen world!
    event_user(1);
}


// call update in each block
for (q=0; q&lt;global.chunkWidth; q+=1)
{
    for (c=0; c&lt;global.chunkHeight; c+=1)
    {
        // get block data
        var WData = walls[# q,c];
        var GData = ground[# q,c];
        var FData = floors[# q,c];
        
        
        if(WData == -1 || scr_BlockCheckRule(WData,"Transparent"))
        {
            // GROUND UPDATE SEGMENT! ==========================================================================================================
            if(GData != -1)
            {
                var xxx = GData[? "x"];
                var yyy = GData[? "y"];
                var zzz = GData[? "z"];
            
                // can see ground
                // run update script for block type
                var forceRenderBlock = false;
                
                if(GData[? "UpdateTick"] &lt; floor(global.worldTick))
                {
                    forceRenderBlock = scr_BlockUpdateScripts(id,xxx,yyy,GData);
                }
                GData[? "UpdateTick"] = floor(global.worldTick);
                
                // can see ground under the floor
                if(rendering &amp;&amp; (forceRenderBlock || forceRenderUpdate))
                {
                    if(FData == -1 || scr_BlockCheckRule(FData,"Transparent"))
                    {
                        // render GROUND
                        forceRenderBlock = false;
                        
                        // clean block graphics
                        if(puppetGround[# q,c] != -1)
                        {
                            var getPackIn = puppetGround[# q,c];
                            while(ds_list_size(getPackIn) &gt; 0)
                            {
                                tile_delete( getPackIn[| 0]);
                                ds_list_delete(getPackIn,0);
                            }
                            ds_list_destroy(getPackIn);
                            puppetGround[# q,c] = -1;
                        }
                        
                        // spawn updated puppet!
                        puppetGround[# q,c] = scr_BlockDataToGroundTile(GData,id,q,c);
                    }
                }
            }
            
            
            // floors cannot exist under a wall!
            if(WData == -1)
            {
                // FLOOR UPDATE SEGMENT! ==========================================================================================================
                if(FData != -1)
                {
                    var xxx = FData[? "x"];
                    var yyy = FData[? "y"];
                    var zzz = FData[? "z"];
                    
                    // run update script for block type
                    var forceRenderBlock = false;
                    
                    if(FData[? "UpdateTick"] &lt; floor(global.worldTick))
                    {
                        forceRenderBlock = scr_BlockUpdateScripts(id,xxx,yyy,FData);
                    }
                    FData[? "UpdateTick"] = floor(global.worldTick);
                    
                    if(rendering &amp;&amp; (forceRenderBlock || forceRenderUpdate))
                    {
                        // render FLOOR
                        forceRenderBlock = false;
                        
                        // clean block graphics
                        if(puppetFloors[# q,c] != -1)
                        {
                            var getPackIn = puppetFloors[# q,c];
                            while(ds_list_size(getPackIn) &gt; 0)
                            {
                                tile_delete( getPackIn[| 0]);
                                ds_list_delete(getPackIn,0);
                            }
                            ds_list_destroy(getPackIn);
                            puppetFloors[# q,c] = -1;
                        }
                        
                        // spawn updated puppet!
                        puppetFloors[# q,c] = scr_BlockDataToFloorTile(FData,id,q,c);
                    }
                }
            }
        }
        else
        {
            // WALL UPDATE SEGMENT! ==========================================================================================================
            var xxx = WData[? "x"];
            var yyy = WData[? "y"];
            var zzz = WData[? "z"];
        
            // run update script for block type
            var forceRenderBlock = false;
            
            if(WData[? "UpdateTick"] &lt; floor(global.worldTick))
            {
                forceRenderBlock = scr_BlockUpdateScripts(id,xxx,yyy,WData);
            }
            WData[? "UpdateTick"] = floor(global.worldTick);
            
            // set visual state of block for drawing
            if(rendering &amp;&amp; (forceRenderBlock || forceRenderUpdate))
            {
                // clean block graphics
                if(puppetWalls[# q,c] != -1)
                {
                    var getPackIn = puppetWalls[# q,c];
                    while(ds_list_size(getPackIn) &gt; 0)
                    {
                        tile_delete( getPackIn[| 0]);
                        ds_list_delete(getPackIn,0);
                    }
                    ds_list_destroy(getPackIn);
                    puppetWalls[# q,c] = -1;
                }
                
                // spawn updated puppet!
                puppetWalls[# q,c] = scr_BlockDataToWallTile(WData,id,q,c);
            }
        }
    }
}


// cleanup one loop flags
forceRenderUpdate = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_destroy();
if(instance_number(obj_WorldChunk) &lt;= 0)
{
    with obj_WorldController instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_rectangle(x,y,x+global.chunkWidth*16,y+global.chunkHeight*16,true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
